# notes from Mikayla

- Odd SDK brings all the fission stuff together, at odd.dev
 - wnfs "Web native filesystem"
 - Authorized via UCan, local first functionality, all passwordless using public / private keypairs.
  - Not accessible by javascript from web crypto
 - Passkeys, walled off plugin with metamask for rooting their identity in that
 - Web crypto is most mature, passkey needs browser support, metamask a bit less
 - Demo is using tensor flow JS to do feature detection and locating of media changes

 - Application data is stored in a local-first file system in the browser
  - When you go online, fission's IPFS nodes are used to sync the data into IPFS
  - IPFS -> Interplanetary file system
  - Used to improve availability
  - essentially "Fission pins your content for you" in content addressable
    - IPFS could lose content because it needs to be continually served, hence why fission is providing them
  - Private file system data is encrypted with your symmetric key generated by web crypto, therefore can't read it from IPFS node
  - Can link browsers with those symmetric keys to sync data automatically, using UCAN to prove authentication
  - UCANs are a capability style system
  - Fission servers decide to allow the write, authorized by the UCAN
  - PVH: How is that local first?
    - Brian: We use a DID to generate this, register it with the server, all of the file system stuff happens locally first, and then the UCAN is used to authorize the writes afterward, essentially control is localized in the user and they can share it around
  - Q: If we have a bunch of bussiness with y'all, and then you get abducted by aliens, what do we do?
    - A: You have to run the fission server, which is open source. There is a root content identifier under which everything else is put. We expose this by DNS, as well as DIDs, to allow you to reference and move your data around
- ODD SDK Can link other devices with a QR code / code, sends the symmetric encryption key and UCAN
- Shares private and public data with other devices

- DXOS w/ Jess:
- DXOS and Odd SDK are very similar, hence the combined talk
- We're all discovering the same things independently
- DXOS is a platform for multiplayer apps
- Fission -> Protocol researhc company making building blocks that everyone else can use.
  DXOS -> Building SDKs that end applications can use, across protocols
- DXOS wants to get to a world of local-first, multiplayer, user-owned data.
- Bottom layer:
    - ECHO database - Local document / graph database in the browser
    - HALO identity - Similar to ODD
- Above, react and typescript SDK
- Above, DXOS apps + Composer
- Above, Plugins
- Local First: Data is stored in browser, and locally.
- TODO list demo: data is shared across tabs, stored locally so very fast
- Has a react hook like API for reading, writing, querying, use simple javascript object updates
- Multiplayer demo: uses device linking similar to what fission is doing, linking to phone
  - Provides chrome for device linking via NPM package
  - provided web socket between the example devices, DXOS provides a dumb TURN server
  - Someone in the room stole the device linking code and used it to link in their android andover 5G
  - Both editing the todo list, very fast and fluid
- DXOS has built a bunch of devtools for this, providing lots of visibility into how the system is working (e.g. network structure, linked devices, etc.).
- Uses libp2p
- Demo: Disconnect from the swarm.
    - Now offline, both editing the todo list
    - After reconnecting to the swarm, it all syncs up again! (kind of, needed a refresh)
    - Using CRDTs to make this happen, at the object-by-object level, not for the whole store
- Echo DB is running per-device
- Interoperable applications:
    - Opens another app, a kanban board
    - Agressively cache to provide true-offline. Caused issues with this demo initially
    - Kanban app syncs to todo list app, reorganizing things in the todo list app, adding new data and different mutations that don't exist in  other applications.
    - Kanban app is running on different domain and application. How do cross domain access?
        - Shared worker works *per-browser*, so that both applications can access the same data despite different domains.
- Right now:
  - Platform does most things, very little application code needed to do things, mostly just reactive updates. can we go further?
  - Composer is a special application that allows you to build applications out of plugins, this whole talk has been a composer app!
